From bb40dee811333929dd467a480dce24ab7af84ef9 Mon Sep 17 00:00:00 2001
From: Jarkko Koivikko <jarkko.koivikko@code-q.fi>
Date: Tue, 8 Jun 2021 15:25:09 +0300
Subject: [PATCH 3/3] Fix processing of hard Qt::Key_Backspace and
 Qt::Key_Delete

Even though the virtual keyboard does not support hard keys at the
moment, this kind of processing could be possible in the future.

In the mean time, fix processing of backspace and delete keys.

In particular, if such key is pressed the pre-edit text is not empty:

- Reset input method state (should not modify pre-edit)
- Clear pre-edit
- Return true (to indicate no further processing is required)

[ChangeLog] Fix processing of hard backspace and delete keys.

Fixes: QTBUG-94017
Pick-to: 5.15 6.1 6.2
Change-Id: I7035f7612e966de6d17d92e754ecd7bdb3a6e530
Reviewed-by: Jarkko Koivikko <jarkko.koivikko@code-q.fi>
(cherry picked from commit ca5b712dfc8e67aece0eb7374ffe5921e2aa45e8)
---
 .../qvirtualkeyboardinputcontext_p.cpp        | 14 ++++++++---
 tests/auto/inputpanel/data/tst_inputpanel.qml | 24 +++++++++++++++++++
 2 files changed, 35 insertions(+), 3 deletions(-)

diff --git a/src/virtualkeyboard/qvirtualkeyboardinputcontext_p.cpp b/src/virtualkeyboard/qvirtualkeyboardinputcontext_p.cpp
index e04c828d..cacf33f0 100644
--- a/src/virtualkeyboard/qvirtualkeyboardinputcontext_p.cpp
+++ b/src/virtualkeyboard/qvirtualkeyboardinputcontext_p.cpp
@@ -507,6 +507,7 @@ bool QVirtualKeyboardInputContextPrivate::filterEvent(const QEvent *event)
     QEvent::Type type = event->type();
     if (type == QEvent::KeyPress || type == QEvent::KeyRelease) {
         const QKeyEvent *keyEvent = static_cast<const QKeyEvent *>(event);
+        const int key = keyEvent->key();
 
         // Keep track of pressed keys update key event state
         if (type == QEvent::KeyPress)
@@ -520,7 +521,6 @@ bool QVirtualKeyboardInputContextPrivate::filterEvent(const QEvent *event)
             setState(State::KeyEvent);
 
 #ifdef QT_VIRTUALKEYBOARD_ARROW_KEY_NAVIGATION
-        int key = keyEvent->key();
         if ((key >= Qt::Key_Left && key <= Qt::Key_Down) || key == Qt::Key_Return) {
             if (type == QEvent::KeyPress && platformInputContext->isInputPanelVisible()) {
                 activeNavigationKeys += key;
@@ -535,8 +535,16 @@ bool QVirtualKeyboardInputContextPrivate::filterEvent(const QEvent *event)
 #endif
 
         // Break composing text since the virtual keyboard does not support hard keyboard events
-        if (!preeditText.isEmpty())
-            commit();
+        if (!preeditText.isEmpty()) {
+            if (type == QEvent::KeyPress && (key == Qt::Key_Delete || key == Qt::Key_Backspace)) {
+                reset();
+                Q_Q(QVirtualKeyboardInputContext);
+                q->clear();
+                return true;
+            } else {
+                commit();
+            }
+        }
     }
 #ifdef QT_VIRTUALKEYBOARD_ARROW_KEY_NAVIGATION
     else if (type == QEvent::ShortcutOverride) {
diff --git a/tests/auto/inputpanel/data/tst_inputpanel.qml b/tests/auto/inputpanel/data/tst_inputpanel.qml
index d814f282..f60acc64 100644
--- a/tests/auto/inputpanel/data/tst_inputpanel.qml
+++ b/tests/auto/inputpanel/data/tst_inputpanel.qml
@@ -321,6 +321,30 @@ Rectangle {
             compare(textInput.text, "A")
         }
 
+        function test_hardKeyBackspaceClearsInput_data() {
+            return [
+                { initLocale: "en_GB", initText: "12345", initCursorPosition: 1, inputSequence: "hello", outputText: "12345", expectedCursorPosition: 1 },
+            ]
+        }
+
+        function test_hardKeyBackspaceClearsInput(data) {
+            prepareTest(data)
+
+            if (!inputPanel.wordCandidateListVisibleHint)
+                skip("Prediction/spell correction not enabled")
+
+            compare(Qt.inputMethod.locale.name, Qt.locale(data.initLocale).name)
+            for (var inputIndex in data.inputSequence) {
+                verify(inputPanel.virtualKeyClick(data.inputSequence[inputIndex]))
+            }
+
+            keyClick(Qt.Key_Backspace)
+            waitForRendering(textInput)
+
+            compare(textInput.text, data.outputText)
+            compare(textInput.cursorPosition, data.expectedCursorPosition)
+        }
+
         function test_hardKeyInput() {
             prepareTest()
 
-- 
2.35.1

